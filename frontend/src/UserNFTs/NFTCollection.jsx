/**
 * This code was generated by Builder.io.
 */
import React, { useState, useEffect } from 'react';
import styles from './UserNFTs.module.css';
import { useSelector } from 'react-redux';
import { toast } from 'react-toastify';
import NFTImage from '../NFTImage';
// import { Navigate } from 'react-router-dom';
import { useNavigate } from 'react-router-dom';


// const fetchOwnedTokens = async () => {
//   if (!contract) {
//     toast.error('Please connect your wallet first.');
//     return;
//   }

//   if (!currentAccount) {
//     toast.error('Please connect your account first.');
//     return;
//   }

//   try {
//     const balance = await contract.balanceOf(currentAccount);
//     const tokens = [];

//     for (let i = 0; i < balance; i++) {
//       const tokenId = await contract.tokenOfOwnerByIndex(currentAccount, i);
//       tokens.push(parseInt(tokenId));
//     }

//     setOwnedTokens(tokens);
//     if (tokens.length === 0) {
//       toast.info('You don\'t have any NFTs.');
//     }
//   } catch (error) {
//     console.error('Error fetching your owned tokens:', error);
//     toast.error('Failed to fetch owned tokens.');
//   }
// };

function NFTCollection() {
  // User owned tokens
  const navigate = useNavigate(); 
  const [ownedTokens, setOwnedTokens] = useState([]);
  const [userNFTs, setUserNFTs] = useState([]); 
  const contract = useSelector((state) => state.contract.contract);
  const currentAccount = useSelector((state) => state.wallet.walletInfo);
  const fetchOwnedTokens = async () => {
    // console.log("contract" + contract);
    if (!contract) {
      toast.error('Please connect your wallet first.');
      return;
    }
    // console.log("wallet" + currentAccount);
    if (!currentAccount) {
      toast.error('Please connect your account first.');
      return;
    }

    try {
      const balance = await contract.balanceOf(currentAccount.address);
      const tokens = [];
      // console.log("balance:" + balance);

      for (let i = 0; i < balance; i++) {
        const tokenId = await contract.tokenOfOwnerByIndex(currentAccount.address, i);
        console.log("tokenId:" + tokenId);
        tokens.push(tokenId);
      }

      setOwnedTokens(tokens);
      if (tokens.length === 0) {
        toast.info('You don\'t have any NFTs.');
      } else {
        // Dynamically create userNFTs from owned tokens
        const fetchedNFTs = tokens.map((tokenId, index) => ({
          id: tokenId,
          image: tokenId, // Replace with your actual NFT image endpoint
          name: `NFT #${tokenId}`,
        }));
        setUserNFTs(fetchedNFTs);
      }
    } catch (error) {
      console.error('Error fetching your owned tokens:', error);
      toast.error('Failed to fetch owned tokens.');
    }
  };

  // const handleList = async () => {
  //   if (!contract) {
  //     toast.error('Please connect your wallet first.');
  //     return;
  //   }

  //   if (!listTokenId || !listPrice) {
  //     toast.error('Please provide valid token ID and price.');
  //     return;
  //   }
  //   const tokenId = parseInt(listTokenId);
  //   const price = parseEther(listPrice);


  //   try {
  //     const tx = await contract.listToken(tokenId, price);
  //     toast.info(`Listing Token ID ${tokenId}...`);
  //     await tx.wait();
  //     toast.success(`Token ID ${tokenId} listed for ${listPrice} ETH`);
  //     setListTokenId('');
  //     setListPrice('');
  //     // fetchListedTokens();
  //     // fetchOwnedTokens(); // Refresh owned NFTs
  //   } catch (error) {
  //     console.error('Listing error:', error);
  //     toast.error('Failed to list NFT.');
  //   }
  // };
  const handleList = (tokenId) => {
    navigate('/list', { state: { tokenId } });
  };
  
  useEffect(() => {
    fetchOwnedTokens();
  }, [contract, currentAccount]);

  // console.log('owned' + fetchOwnedTokens());
  return (
    <section className={styles.nftCollectionSection}>
      <div className={styles.collectionHeader}>
        <div className={styles.collectionInfo}>
          {/* <img src="https://cdn.builder.io/api/v1/image/assets/TEMP/29bf2853fccaab834c292d8776c8e4881ab3e1ea521be3f2f446dd371bee9841?placeholderIfAbsent=true&apiKey=f3aaf6d180294e6db6f355070af6792c" alt="Collection icon" className={styles.collectionIcon} /> */}
          <div>
            <h3 className={styles.collectionName}>Name collection</h3>
            <p className={styles.collectionTimestamp}>10 hours ago</p>
          </div>
        </div>
        <button className={styles.ownButton}>I have it</button>
      </div>
      <hr className={styles.collectionDivider} />
      <div className={styles.nftGrid}>
        {userNFTs.map((item) => (
          <div key={item.id} className={styles.nftItem}>
            {/* <img src={item.image} alt={`NFT ${item.id}`} className={styles.nftImage} /> */}
            <NFTImage tokenId={item.id} />
            {/* <p className={styles.nftName}>{item.name}</p> */}
            <button className={styles.list} onClick={() => handleList(item.id)} >List</button>
            
          </div>
        ))}
      </div>
    </section>
  );
}

export default NFTCollection;